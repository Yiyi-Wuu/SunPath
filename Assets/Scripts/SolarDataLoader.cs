using UnityEngine;
using System;
using System.IO;

// Add to the same GameObject as SunMotion.
// Reads binary solar data from StreamingAssets/SolarData/[cityName]/sun_pos_YYYY.bin
// Generated by Tools → Solar Data → Preprocess CSV to Binary
//
// Query with GetPositionLerped(simDateTime, minuteFraction) to get interpolated sun position.
// Returns (azimuth, elevation) in degrees. elevation = degrees above horizon.
// Convert to zenith: zenith = 90f - elevation.

public class SolarDataLoader : MonoBehaviour
{
    [Header("City")]
    public string cityName = "Manhattan";

    // Packed into a single float[] for cache locality: [azimuth0, elev0, azimuth1, elev1, ...]
    float[] _data;
    int _loadedYear = -1;
    int _totalMinutes;

    const int MINUTES_PER_DAY = 1440;
    const int HEADER_BYTES    = 16;     // 4 magic + 2 version + 2 year + 4 totalMinutes + 4 reserved

    // ------------------------------------------------------------------
    // Public API
    // ------------------------------------------------------------------

    // Load (or switch to) a year. Call on Start and on year rollover.
    // Returns true on success.
    public bool LoadYear(int year)
    {
        if (_loadedYear == year) return true;

        string path = BinPath(year);
        if (!File.Exists(path))
        {
            Debug.LogError($"[SolarDataLoader] File not found: {path}\n" +
                           "Run Tools → Solar Data → Preprocess CSV to Binary first.");
            return false;
        }

        using var reader = new BinaryReader(File.Open(path, FileMode.Open, FileAccess.Read));

        if (!ReadAndValidateHeader(reader, year, out int totalMinutes))
            return false;

        _totalMinutes = totalMinutes;
        _data = new float[totalMinutes * 2];

        for (int i = 0; i < totalMinutes; i++)
        {
            _data[i * 2]     = reader.ReadSingle(); // azimuth
            _data[i * 2 + 1] = reader.ReadSingle(); // elevation
        }

        _loadedYear = year;
        long fileBytes = totalMinutes * 8L + HEADER_BYTES;
        Debug.Log($"[SolarDataLoader] Loaded {cityName} {year}: {totalMinutes:N0} minutes ({fileBytes / 1024f / 1024f:F1} MB read)");
        return true;
    }

    // Raw lookup — no interpolation.
    // dayOfYear: 1-based (1 = Jan 1, 365/366 = Dec 31)
    // minuteOfDay: 0–1439
    public (float azimuth, float elevation) GetPosition(int dayOfYear, int minuteOfDay)
    {
        if (_data == null) return (0f, -90f);

        int index = (dayOfYear - 1) * MINUTES_PER_DAY + minuteOfDay;
        index = Mathf.Clamp(index, 0, _totalMinutes - 1);
        return (_data[index * 2], _data[index * 2 + 1]);
    }

    // Interpolated lookup. minuteFraction is the sub-minute progress [0, 1).
    // This is what SunMotion should call each frame.
    public (float azimuth, float elevation) GetPositionLerped(DateTime localTime, float minuteFraction)
    {
        if (_data == null) return (0f, -90f);

        int dayOfYear   = localTime.DayOfYear;
        int minuteOfDay = localTime.Hour * 60 + localTime.Minute;

        var curr = GetPosition(dayOfYear, minuteOfDay);

        // Wrap next-minute across day/year boundaries
        int nextMinute = minuteOfDay + 1;
        int nextDay    = dayOfYear;
        if (nextMinute >= MINUTES_PER_DAY) { nextMinute = 0; nextDay++; }
        if (nextDay > _totalMinutes / MINUTES_PER_DAY) nextDay = 1; // year wrap

        var next = GetPosition(nextDay, nextMinute);

        return (
            Mathf.LerpAngle(curr.azimuth,   next.azimuth,   minuteFraction),
            Mathf.Lerp     (curr.elevation,  next.elevation, minuteFraction)
        );
    }

    public bool IsLoaded => _loadedYear >= 0 && _data != null;

    // ------------------------------------------------------------------
    // Internal
    // ------------------------------------------------------------------

    string BinPath(int year) =>
        Path.Combine(Application.streamingAssetsPath, "SolarData", cityName, $"sun_pos_{year}.bin");

    bool ReadAndValidateHeader(BinaryReader reader, int expectedYear, out int totalMinutes)
    {
        totalMinutes = 0;

        byte s = reader.ReadByte();
        byte l = reader.ReadByte();
        byte r = reader.ReadByte();
        byte d = reader.ReadByte();

        if (s != 'S' || l != 'L' || r != 'R' || d != 'D')
        {
            Debug.LogError("[SolarDataLoader] Invalid file magic — not a solar data binary.");
            return false;
        }

        short version  = reader.ReadInt16();
        short fileYear = reader.ReadInt16();
        totalMinutes   = reader.ReadInt32();
        reader.ReadInt32(); // reserved

        if (version != 1)
        {
            Debug.LogError($"[SolarDataLoader] Unsupported binary version {version}.");
            return false;
        }

        if (fileYear != expectedYear)
        {
            Debug.LogWarning($"[SolarDataLoader] File year {fileYear} doesn't match requested year {expectedYear}.");
        }

        return true;
    }
}
